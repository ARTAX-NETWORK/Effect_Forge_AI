import { randomUUID } from "crypto";
import { aiEngine, type EffectDNA } from "./ai-engine";
import type { EffectGenerationRequest, InsertEffect } from "@shared/schema";

export interface GeneratedEffect extends InsertEffect {
  id: string;
  dna: EffectDNA;
}

class EffectGeneratorService {
  async generateEffect(request: EffectGenerationRequest): Promise<GeneratedEffect> {
    try {
      // Phase 1: DÉCONSTRUIRE - Analyze the prompt
      const dna = await aiEngine.analyzeContent(request.prompt);
      
      // Phase 2: AMÉLIORER - Generate base effect code
      const baseCode = await this.generateBaseCode(request, dna);
      
      // Phase 3: AMPLIFIER - Optimize for performance and requirements
      const optimizedCode = await this.optimizeCode(baseCode, request);
      
      // Phase 4: RECONSTRUIRE - Build final effect with metadata
      const effect = await this.reconstructEffect(request, dna, optimizedCode);
      
      return effect;
    } catch (error) {
      throw new Error(`Effect generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async generateBaseCode(request: EffectGenerationRequest, dna: EffectDNA): Promise<{
    javascript?: string;
    css?: string;
    afterEffects?: string;
  }> {
    const code: any = {};

    if (request.type === 'javascript' || request.type === 'all') {
      code.javascript = await this.generateJavaScriptCode(dna, request);
    }

    if (request.type === 'css' || request.type === 'all') {
      code.css = await this.generateCSSCode(dna, request);
    }

    if (request.type === 'aftereffects' || request.type === 'all') {
      code.afterEffects = await this.generateAfterEffectsCode(dna, request);
    }

    return code;
  }

  private async generateJavaScriptCode(dna: EffectDNA, request: EffectGenerationRequest): Promise<string> {
    const effectName = this.generateEffectName(dna);
    const className = this.toCamelCase(effectName) + 'Effect';

    return `
/**
 * ${effectName} - Generated by EffectForge AI
 * Constitutional Compliance: ${request.enableConstitution ? 'ENABLED' : 'DISABLED'}
 * Performance Target: ${request.targetFps}fps, ${request.maxMemory}MB
 */
class ${className} {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      // DNA-based parameters
      energy: ${dna.emotionalProfile.energy.toFixed(2)},
      complexity: ${dna.emotionalProfile.complexity.toFixed(2)},
      elegance: ${dna.emotionalProfile.elegance.toFixed(2)},
      
      // Performance parameters
      targetFPS: ${request.targetFps},
      maxMemory: ${request.maxMemory},
      
      // User overrides
      ...options
    };
    
    ${request.enableConstitution ? this.getConstitutionalSetup() : '// Constitutional compliance disabled'}
    
    this.init();
  }
  
  init() {
    this.canvas = this.createCanvas();
    this.ctx = this.canvas.getContext('2d');
    this.particles = [];
    this.animationId = null;
    this.lastFrameTime = 0;
    
    this.setupCanvas();
    this.createParticles();
    this.bindEvents();
    this.start();
  }
  
  createCanvas() {
    const canvas = document.createElement('canvas');
    canvas.width = this.container.clientWidth || 800;
    canvas.height = this.container.clientHeight || 600;
    this.container.appendChild(canvas);
    return canvas;
  }
  
  setupCanvas() {
    // High-quality rendering setup
    this.ctx.imageSmoothingEnabled = true;
    this.ctx.imageSmoothingQuality = 'high';
    
    // Apply elegance-based quality settings
    if (this.options.elegance > 0.7) {
      this.ctx.shadowBlur = 10;
      this.ctx.shadowColor = 'rgba(0, 212, 255, 0.3)';
    }
  }
  
  createParticles() {
    const particleCount = Math.floor(50 + (this.options.complexity * 100));
    
    for (let i = 0; i < particleCount; i++) {
      this.particles.push(new Particle({
        x: Math.random() * this.canvas.width,
        y: Math.random() * this.canvas.height,
        energy: this.options.energy,
        complexity: this.options.complexity,
        elegance: this.options.elegance
      }));
    }
  }
  
  render(currentTime = 0) {
    // Performance monitoring
    const deltaTime = currentTime - this.lastFrameTime;
    const fps = 1000 / deltaTime;
    
    ${request.enableConstitution ? this.getPerformanceMonitoring() : ''}
    
    // Clear canvas
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Render background effect
    this.renderBackground(currentTime);
    
    // Update and render particles
    this.particles.forEach(particle => {
      particle.update(deltaTime, this.options);
      particle.render(this.ctx);
    });
    
    // Apply post-processing effects
    this.applyPostProcessing();
    
    this.lastFrameTime = currentTime;
    this.animationId = requestAnimationFrame((time) => this.render(time));
  }
  
  renderBackground(time) {
    const gradient = this.ctx.createRadialGradient(
      this.canvas.width / 2, this.canvas.height / 2, 0,
      this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) / 2
    );
    
    const hue = (time * 0.001 * this.options.energy * 50) % 360;
    gradient.addColorStop(0, \`hsla(\${hue}, 70%, 20%, \${this.options.elegance * 0.3})\`);
    gradient.addColorStop(1, 'transparent');
    
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  applyPostProcessing() {
    if (this.options.elegance > 0.5) {
      // Apply glow effect
      this.ctx.globalCompositeOperation = 'lighter';
      this.ctx.filter = \`blur(\${this.options.elegance * 2}px)\`;
      this.ctx.globalAlpha = 0.3;
      
      // Re-render particles with glow
      this.particles.forEach(particle => {
        particle.render(this.ctx);
      });
      
      // Reset rendering state
      this.ctx.globalCompositeOperation = 'source-over';
      this.ctx.filter = 'none';
      this.ctx.globalAlpha = 1;
    }
  }
  
  start() {
    if (!this.animationId) {
      this.render();
    }
  }
  
  stop() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }
  
  destroy() {
    this.stop();
    if (this.canvas && this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
    this.particles = [];
  }
  
  bindEvents() {
    // Interactive features based on energy level
    if (this.options.energy > 0.6) {
      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        this.particles.forEach(particle => {
          particle.attractTo(x, y, this.options.energy);
        });
      });
    }
  }
}

class Particle {
  constructor(options) {
    this.x = options.x;
    this.y = options.y;
    this.vx = (Math.random() - 0.5) * options.energy * 4;
    this.vy = (Math.random() - 0.5) * options.energy * 4;
    this.size = Math.random() * options.complexity * 5 + 1;
    this.life = 1;
    this.decay = 0.01 * (2 - options.elegance);
    this.color = this.generateColor(options);
  }
  
  generateColor(options) {
    const hue = Math.random() * 360;
    const saturation = 50 + options.energy * 50;
    const lightness = 30 + options.elegance * 40;
    return \`hsl(\${hue}, \${saturation}%, \${lightness}%)\`;
  }
  
  update(deltaTime, options) {
    this.x += this.vx * deltaTime * 0.1;
    this.y += this.vy * deltaTime * 0.1;
    this.life -= this.decay;
    
    // Apply complexity-based physics
    if (options.complexity > 0.5) {
      this.vx *= 0.99; // Friction
      this.vy *= 0.99;
      this.vy += 0.1; // Gravity
    }
    
    // Respawn particle if it dies
    if (this.life <= 0) {
      this.respawn(options);
    }
  }
  
  respawn(options) {
    this.x = Math.random() * 800; // Canvas width
    this.y = Math.random() * 600; // Canvas height
    this.vx = (Math.random() - 0.5) * options.energy * 4;
    this.vy = (Math.random() - 0.5) * options.energy * 4;
    this.life = 1;
    this.color = this.generateColor(options);
  }
  
  attractTo(x, y, strength) {
    const dx = x - this.x;
    const dy = y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 0) {
      this.vx += (dx / distance) * strength * 0.1;
      this.vy += (dy / distance) * strength * 0.1;
    }
  }
  
  render(ctx) {
    ctx.save();
    ctx.globalAlpha = this.life;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ${className};
} else if (typeof window !== 'undefined') {
  window.${className} = ${className};
}`;
  }

  private async generateCSSCode(dna: EffectDNA, request: EffectGenerationRequest): Promise<string> {
    const effectName = this.generateEffectName(dna);
    const className = this.toKebabCase(effectName) + '-effect';

    return `
/* ${effectName} - Generated by EffectForge AI */
/* Constitutional Compliance: ${request.enableConstitution ? 'ENABLED' : 'DISABLED'} */

.${className} {
  /* DNA-based properties */
  --energy: ${dna.emotionalProfile.energy.toFixed(2)};
  --complexity: ${dna.emotionalProfile.complexity.toFixed(2)};
  --elegance: ${dna.emotionalProfile.elegance.toFixed(2)};
  
  /* Performance optimizations */
  will-change: transform, opacity;
  backface-visibility: hidden;
  perspective: 1000px;
  
  /* Base animation */
  animation: ${className}-animation calc(var(--energy) * 3s + 1s) infinite ease-in-out;
  transform-origin: center;
  
  /* Visual properties based on DNA */
  filter: 
    blur(calc(var(--elegance) * 2px))
    brightness(calc(1 + var(--complexity) * 0.5))
    saturate(calc(1 + var(--energy) * 0.8));
  
  /* Constitutional compliance features */
  ${request.enableConstitution ? `
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  transform: translateZ(0); /* Force hardware acceleration */
  ` : ''}
}

@keyframes ${className}-animation {
  0% {
    transform: 
      scale(1) 
      rotate(0deg) 
      translateX(0);
    opacity: var(--elegance);
  }
  
  25% {
    transform: 
      scale(calc(1 + var(--complexity) * 0.3)) 
      rotate(calc(var(--energy) * 90deg)) 
      translateX(calc(var(--energy) * 20px));
    opacity: 1;
  }
  
  50% {
    transform: 
      scale(calc(1 + var(--complexity) * 0.5)) 
      rotate(calc(var(--energy) * 180deg)) 
      translateX(0);
    opacity: calc(var(--elegance) + 0.3);
  }
  
  75% {
    transform: 
      scale(calc(1 + var(--complexity) * 0.3)) 
      rotate(calc(var(--energy) * 270deg)) 
      translateX(calc(var(--energy) * -20px));
    opacity: 1;
  }
  
  100% {
    transform: 
      scale(1) 
      rotate(calc(var(--energy) * 360deg)) 
      translateX(0);
    opacity: var(--elegance);
  }
}

/* Interactive states */
.${className}:hover {
  animation-duration: calc(var(--energy) * 1s + 0.5s);
  filter: 
    blur(calc(var(--elegance) * 1px))
    brightness(calc(1.2 + var(--complexity) * 0.3))
    saturate(calc(1.2 + var(--energy) * 0.5));
}

/* Responsive adaptations */
@media (max-width: 768px) {
  .${className} {
    animation-duration: calc(var(--energy) * 2s + 1s);
    filter: 
      blur(calc(var(--elegance) * 1px))
      brightness(calc(1 + var(--complexity) * 0.3))
      saturate(calc(1 + var(--energy) * 0.5));
  }
}

@media (prefers-reduced-motion: reduce) {
  .${className} {
    animation: none;
    transform: none;
  }
}

/* High performance mode */
@media (min-resolution: 2dppx) {
  .${className} {
    transform: translate3d(0, 0, 0);
    filter: none; /* Disable filters on high-DPI displays for performance */
  }
}`;
  }

  private async generateAfterEffectsCode(dna: EffectDNA, request: EffectGenerationRequest): Promise<string> {
    const effectName = this.generateEffectName(dna);

    return `
// ${effectName} - Generated by EffectForge AI
// After Effects Expression - Constitutional Compliance

// DNA Parameters
var energy = ${dna.emotionalProfile.energy.toFixed(3)};
var complexity = ${dna.emotionalProfile.complexity.toFixed(3)};
var elegance = ${dna.emotionalProfile.elegance.toFixed(3)};

// Performance settings
var targetFPS = ${request.targetFps};
var maxMemory = ${request.maxMemory};

// Constitutional compliance checks
${request.enableConstitution ? `
// Article I: Performance Absolue
if (thisComp.frameRate < targetFPS) {
  energy *= 0.8;
  complexity *= 0.9;
}

// Article II: Intelligence Adaptative
var devicePerformance = thisComp.width * thisComp.height > 1920 * 1080 ? 'high' : 'low';
if (devicePerformance === 'low') {
  complexity = Math.min(complexity, 0.7);
}

// Article III: Polyvalence Universelle
var renderEngine = app.project.renderQueue.item(1).outputModule(1).name;
var isH264 = renderEngine.indexOf('H.264') > -1;
if (isH264) {
  // Optimize for H.264 compression
  elegance = Math.min(elegance, 0.8);
}
` : '// Constitutional compliance disabled'}

// Time-based calculations
var t = time;
var freq = energy * 2 + 0.5; // Frequency based on energy
var amp = complexity * 100 + 50; // Amplitude based on complexity

// Base position calculation
var basePos = transform.position;

// Energy-driven movement
var energyX = Math.sin(t * freq) * amp * energy;
var energyY = Math.cos(t * freq * 0.7) * amp * energy * 0.8;

// Complexity-driven secondary motion
var complexX = Math.sin(t * freq * complexity * 2) * amp * complexity * 0.3;
var complexY = Math.cos(t * freq * complexity * 1.5) * amp * complexity * 0.3;

// Elegance-driven smoothing
var smoothingFactor = elegance * 0.1 + 0.02;
var smoothX = linear(t, 0, 1, 0, energyX + complexX) * (1 - smoothingFactor) + 
              (energyX + complexX) * smoothingFactor;
var smoothY = linear(t, 0, 1, 0, energyY + complexY) * (1 - smoothingFactor) + 
              (energyY + complexY) * smoothingFactor;

// Final position with constitutional compliance
var finalX = basePos[0] + smoothX;
var finalY = basePos[1] + smoothY;

// Performance optimization: limit extreme values
finalX = Math.max(-2000, Math.min(2000, finalX));
finalY = Math.max(-2000, Math.min(2000, finalY));

// Return the calculated position
[finalX, finalY];

/* 
SCALE EXPRESSION (apply to Scale property):

var scaleBase = transform.scale;
var energyScale = 1 + Math.sin(time * energy * 3) * energy * 0.2;
var complexityScale = 1 + Math.sin(time * complexity * 2) * complexity * 0.1;
var eleganceSmoothing = elegance * 0.05;

var finalScale = scaleBase * energyScale * complexityScale;
finalScale = [
  Math.max(50, Math.min(200, finalScale[0])),
  Math.max(50, Math.min(200, finalScale[1]))
];

[finalScale[0], finalScale[1]];
*/

/* 
ROTATION EXPRESSION (apply to Rotation property):

var rotationBase = transform.rotation;
var energyRotation = energy * 360 * Math.sin(time * energy);
var complexityRotation = complexity * 180 * Math.cos(time * complexity * 0.5);
var eleganceSmoothing = elegance * 0.1;

var finalRotation = rotationBase + 
  (energyRotation * (1 - eleganceSmoothing)) + 
  (complexityRotation * eleganceSmoothing);

finalRotation % 360;
*/

/* 
OPACITY EXPRESSION (apply to Opacity property):

var baseOpacity = transform.opacity;
var energyPulse = 20 + energy * 30 * Math.sin(time * energy * 4);
var eleganceStability = elegance * 60 + 20;

var finalOpacity = Math.min(100, Math.max(10, 
  baseOpacity + energyPulse + eleganceStability
));

finalOpacity;
*/`;
  }

  private async optimizeCode(code: any, request: EffectGenerationRequest): Promise<any> {
    const optimized = { ...code };

    // Performance optimization for each code type
    if (optimized.javascript) {
      optimized.javascript = await aiEngine.optimizeCode(optimized.javascript, 'performance');
    }

    if (optimized.css) {
      // CSS-specific optimizations
      optimized.css = this.optimizeCSSPerformance(optimized.css, request);
    }

    if (optimized.afterEffects) {
      // AE-specific optimizations
      optimized.afterEffects = this.optimizeAEPerformance(optimized.afterEffects, request);
    }

    return optimized;
  }

  private optimizeCSSPerformance(css: string, request: EffectGenerationRequest): string {
    let optimized = css;

    // Add hardware acceleration hints
    if (request.targetFps >= 60) {
      optimized = optimized.replace(
        'will-change: transform, opacity;',
        'will-change: transform, opacity;\n  transform: translate3d(0, 0, 0);'
      );
    }

    // Reduce complexity for lower memory targets
    if (request.maxMemory < 256) {
      optimized = optimized.replace(/blur\(calc\(.*?\)\)/g, 'blur(1px)');
    }

    return optimized;
  }

  private optimizeAEPerformance(ae: string, request: EffectGenerationRequest): string {
    let optimized = ae;

    // Add memory optimization for lower targets
    if (request.maxMemory < 512) {
      optimized = optimized.replace(
        'var amp = complexity * 100 + 50;',
        'var amp = Math.min(complexity * 100 + 50, 75);'
      );
    }

    // Add frame rate optimization
    if (request.targetFps < 60) {
      optimized = optimized.replace(
        'var freq = energy * 2 + 0.5;',
        'var freq = energy * 1.5 + 0.3;'
      );
    }

    return optimized;
  }

  private async reconstructEffect(
    request: EffectGenerationRequest, 
    dna: EffectDNA, 
    code: any
  ): Promise<GeneratedEffect> {
    const effectName = this.generateEffectName(dna);
    const category = this.determineCategory(dna);
    const tags = this.generateTags(dna);

    return {
      id: randomUUID(),
      name: effectName,
      description: request.prompt,
      category,
      type: request.type,
      tags,
      
      // Code implementations
      javascriptCode: code.javascript || null,
      cssCode: code.css || null,
      afterEffectsCode: code.afterEffects || null,
      
      // Constitutional compliance (will be set by constitution validator)
      constitutionScore: 0,
      performanceCompliant: false,
      intelligenceAdaptive: false,
      universalCompatible: false,
      perfectExperience: false,
      visualImpact: false,
      addictiveEcosystem: false,
      competitiveDomination: false,
      
      // Performance metrics
      renderTime: this.estimateRenderTime(dna, request),
      memoryUsage: this.estimateMemoryUsage(dna, request),
      targetFps: request.targetFps,
      
      // Metadata
      generatedBy: 'AI',
      generationPrompt: request.prompt,
      
      // Additional DNA reference
      dna,
    };
  }

  private generateEffectName(dna: EffectDNA): string {
    const concepts = dna.primaryConcepts.slice(0, 2);
    const energyWords = ['Dynamic', 'Pulsing', 'Flowing', 'Static'];
    const eleganceWords = ['Elegant', 'Smooth', 'Refined', 'Raw'];
    
    const energyWord = energyWords[Math.floor(dna.emotionalProfile.energy * energyWords.length)];
    const eleganceWord = eleganceWords[Math.floor(dna.emotionalProfile.elegance * eleganceWords.length)];
    
    if (concepts.length >= 2) {
      return `${eleganceWord} ${concepts[0]} ${concepts[1]}`;
    } else if (concepts.length === 1) {
      return `${energyWord} ${concepts[0]} Effect`;
    } else {
      return `${energyWord} ${eleganceWord} Effect`;
    }
  }

  private determineCategory(dna: EffectDNA): string {
    const concepts = dna.primaryConcepts;
    
    if (concepts.some(c => ['particle', 'explosion', 'dust', 'sparkle'].includes(c))) {
      return 'particle';
    }
    if (concepts.some(c => ['fade', 'slide', 'zoom', 'flip'].includes(c))) {
      return 'transition';
    }
    if (concepts.some(c => ['bounce', 'pulse', 'wiggle', 'shake'].includes(c))) {
      return 'animation';
    }
    if (concepts.some(c => ['glow', 'blur', 'shadow', 'gradient'].includes(c))) {
      return 'filter';
    }
    
    return 'visual';
  }

  private generateTags(dna: EffectDNA): string[] {
    const tags = [...dna.primaryConcepts];
    
    // Add energy-based tags
    if (dna.emotionalProfile.energy > 0.7) {
      tags.push('high-energy', 'dynamic');
    } else if (dna.emotionalProfile.energy < 0.3) {
      tags.push('subtle', 'calm');
    }
    
    // Add complexity-based tags
    if (dna.emotionalProfile.complexity > 0.7) {
      tags.push('complex', 'detailed');
    } else if (dna.emotionalProfile.complexity < 0.3) {
      tags.push('simple', 'minimal');
    }
    
    // Add elegance-based tags
    if (dna.emotionalProfile.elegance > 0.7) {
      tags.push('elegant', 'smooth');
    } else if (dna.emotionalProfile.elegance < 0.3) {
      tags.push('rough', 'raw');
    }
    
    return Array.from(new Set(tags)); // Remove duplicates
  }

  private estimateRenderTime(dna: EffectDNA, request: EffectGenerationRequest): number {
    // Base render time calculation
    let baseTime = 10; // 10ms base
    
    // Complexity factor
    baseTime += dna.emotionalProfile.complexity * 15;
    
    // Energy factor (more movement = more calculations)
    baseTime += dna.emotionalProfile.energy * 10;
    
    // Target FPS factor
    if (request.targetFps > 30) {
      baseTime *= 1.2;
    }
    
    // Type factor
    if (request.type === 'aftereffects') {
      baseTime *= 0.8; // AE is more optimized
    } else if (request.type === 'css') {
      baseTime *= 0.6; // CSS is hardware accelerated
    }
    
    return Math.round(Math.max(5, Math.min(50, baseTime)));
  }

  private estimateMemoryUsage(dna: EffectDNA, request: EffectGenerationRequest): number {
    // Base memory usage
    let baseMemory = 32; // 32MB base
    
    // Complexity factor
    baseMemory += dna.emotionalProfile.complexity * 64;
    
    // Energy factor (more particles = more memory)
    baseMemory += dna.emotionalProfile.energy * 32;
    
    // Type factor
    if (request.type === 'javascript') {
      baseMemory *= 1.5; // JS uses more memory for particles
    } else if (request.type === 'css') {
      baseMemory *= 0.5; // CSS is more memory efficient
    }
    
    return Math.round(Math.max(32, Math.min(request.maxMemory, baseMemory)));
  }

  private getConstitutionalSetup(): string {
    return `
    // Constitutional Compliance Setup
    this.setupConstitutionalCompliance();
  }
  
  setupConstitutionalCompliance() {
    // Article I: Performance Absolue
    this.targetFPS = this.options.targetFPS;
    this.frameTime = 1000 / this.targetFPS;
    this.performanceMonitor = new PerformanceMonitor();
    
    // Article II: Intelligence Adaptative
    this.autoCalibrate();
    this.setupAdaptiveParameters();
    
    // Article III: Polyvalence Universelle
    this.detectPlatform();
    this.setupCrossBrowserCompat();
    
    // Article IV: Expérience Parfaite
    this.enableOneClickOperation();
    
    // Article V: Impact Visuel
    this.enhanceVisualImpact();
  }
  
  autoCalibrate() {
    const deviceCapacity = this.detectDeviceCapacity();
    this.adjustParametersForDevice(deviceCapacity);
  }
  
  detectDeviceCapacity() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl');
    return gl ? 'high' : 'low';
  }
  
  setupAdaptiveParameters() {
    // Adjust particle count based on performance
    setInterval(() => {
      const currentFPS = this.performanceMonitor.getCurrentFPS();
      if (currentFPS < this.targetFPS * 0.9) {
        this.reduceComplexity();
      } else if (currentFPS > this.targetFPS * 1.1) {
        this.increaseComplexity();
      }
    }, 1000);
  }
  
  detectPlatform() {
    this.platform = /Mobile|Android|iPhone|iPad/.test(navigator.userAgent) ? 'mobile' : 'desktop';
  }
  
  setupCrossBrowserCompat() {
    // Polyfills and compatibility fixes
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.setTimeout;
    }`;
  }

  private getPerformanceMonitoring(): string {
    return `
    // Performance monitoring and optimization
    if (fps < this.options.targetFPS * 0.9) {
      // Reduce particle count or quality
      if (this.particles.length > 10) {
        this.particles.splice(-5); // Remove 5 particles
      }
    }
    
    // Memory usage check
    if (performance.memory && performance.memory.usedJSHeapSize > this.options.maxMemory * 1024 * 1024) {
      this.optimizeMemoryUsage();
    }`;
  }

  private toCamelCase(str: string): string {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => {
      return index === 0 ? word.toLowerCase() : word.toUpperCase();
    }).replace(/\s+/g, '');
  }

  private toKebabCase(str: string): string {
    return str.replace(/\s+/g, '-').toLowerCase();
  }
}

export const effectGenerator = new EffectGeneratorService();
